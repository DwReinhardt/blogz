
"""
Collate Resume Bullets (Role-separated Experience) - Interactive

Purpose:
- Parse multiple .docx resumes and aggregate bullet points into a single Word document.
- Separate bullets under Experience/Professional Experience by detected "role" headers (e.g., Title — Company — Dates).
- Include bullets from other specified sections.
- Deduplicate bullets and canonicalize section names to your configured list.
- Prompt for input folder and output file if not provided via command-line; GUI pickers available with --gui.

Usage:
    # Console prompts
    python collate_resume_bullets_roles_prompt.py

    # GUI pickers
    python collate_resume_bullets_roles_prompt.py --gui

    # CLI arguments (no prompts)
    python collate_resume_bullets_roles_prompt.py "<input_folder>" "<output_docx>"

Dependencies:
- python-docx (install with: pip install python-docx)

Author:
- Code generated by Copilot (GPT-4) 
- Adapted for Duane Reinhardt with expanded sections and documentation.
"""

import os
import re
import sys
from collections import defaultdict
from docx import Document
from docx.shared import Pt

# =============================================================================
# CONFIGURATION & CONSTANTS
# =============================================================================
# --- Sections to include (canonical set) ---
SECTIONS_TO_INCLUDE = {
    "Professional Profile",
    "Technical Skills",
    "Professional Experience",
    "Additional Skills & Qualifications",
    "Experience",
    "Core Competencies",
    "Skills",
    "Education",
    "Certifications",
    "Summary",
}

# Preferences
DEDUPLICATE_BULLETS = True           # remove duplicate bullets (case-insensitive)
TAG_WITH_FILENAME = False            # do NOT tag bullets with source file name
BULLET_CHARS = {"•", "-", "–", "*", "·"}  # common bullet glyphs

# Canonical mapping: normalize common variants to your canonical list above
CANONICAL_MAP = {
    # Experience family
    "Work Experience": "Experience",
    "Employment": "Experience",
    "Professional Experience": "Professional Experience",  # keep as provided
    # Summary family
    "Professional Summary": "Summary",
    "Objective": "Summary",
    "Profile": "Professional Profile",
    # Skills family
    "Technical Skills": "Technical Skills",
    "Core Competency": "Core Competencies",
    "Competencies": "Core Competencies",
    "Additional Skills": "Additional Skills & Qualifications",
    "Additional Qualifications": "Additional Skills & Qualifications",
    # Certifications
    "Certs": "Certifications",
}

# Heading detection regexes (case-insensitive)
HEADING_REGEXES = [
    r"^\s*(professional profile|profile)\s*:?\s*$",
    r"^\s*(technical skills)\s*:?\s*$",
    r"^\s*(professional experience|experience|work experience|employment)\s*:?\s*$",
    r"^\s*(additional skills & qualifications|additional skills|additional qualifications)\s*:?\s*$",
    r"^\s*(core competencies|competencies|core competency)\s*:?\s*$",
    r"^\s*(skills)\s*:?\s*$",
    r"^\s*(education)\s*:?\s*$",
    r"^\s*(certifications|certs)\s*:?\s*$",
    r"^\s*(summary|objective|professional summary)\s*:?\s*$",
]
HEADING_COMPILED = [re.compile(rx, re.IGNORECASE) for rx in HEADING_REGEXES]

# Date patterns commonly found in role headers
DATE_PATTERNS = [
    r"\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec)\s+\d{4}\b",
    r"\b\d{4}\b",
    r"\b\d{1,2}/\d{4}\b",
]
DATE_RANGE = re.compile(
    r"(" + "|".join(DATE_PATTERNS) + r")\s*(?:[-–—]\s*|to\s+)\s*(?:Present|Current|Now|" + "|".join(DATE_PATTERNS) + r")",
    re.IGNORECASE
)

# =============================================================================
# INPUT PROMPTS & GUI PICKERS
# =============================================================================
def prompt_for_folder(prompt_text: str) -> str:
    """Console prompt to get a valid folder path."""
    while True:
        path = input(f"{prompt_text}\n> ").strip().strip('"')
        if not path:
            print("Please enter a non-empty path.")
            continue
        if not os.path.isdir(path):
            print(f"Path does not exist or is not a folder: {path}")
            continue
        return path

def prompt_for_output_docx(prompt_text: str) -> str:
    """Console prompt to get a valid .docx output path; creates parent if needed."""
    while True:
        path = input(f"{prompt_text}\n> ").strip().strip('"')
        if not path:
            print("Please enter a non-empty path.")
            continue
        if not path.lower().endswith(".docx"):
            print("Output must end with .docx (e.g., C:\\...\\Collated Bullets - Resumes.docx)")
            continue
        parent = os.path.dirname(path) or "."
        try:
            os.makedirs(parent, exist_ok=True)
        except Exception as e:
            print(f"Cannot create/access parent folder '{parent}': {e}")
            continue
        return path

def pick_paths_gui() -> tuple[str, str]:
    """
    GUI pickers using tkinter: select input folder and save-as output .docx.
    Falls back to console prompts if tkinter unavailable.
    """
    try:
        import tkinter as tk
        from tkinter import filedialog
        root = tk.Tk()
        root.withdraw()

        input_folder = filedialog.askdirectory(title="Select folder containing .docx resumes")
        if not input_folder:
            print("No input folder selected. Falling back to console prompt.")
            input_folder = prompt_for_folder("Enter the input folder path (OneDrive-synced folder with .docx resumes):")

        output_docx = filedialog.asksaveasfilename(
            title="Choose output .docx",
            defaultextension=".docx",
            filetypes=[("Word Document", "*.docx")],
            initialfile="Collated Bullets - Resumes.docx"
        )
        if not output_docx:
            print("No output file selected. Falling back to console prompt.")
            output_docx = prompt_for_output_docx("Enter the full output .docx path:")

        return input_folder, output_docx
    except Exception:
        print("GUI pickers unavailable. Using console prompts.")
        input_folder = prompt_for_folder("Enter the input folder path (OneDrive-synced folder with .docx resumes):")
        output_docx = prompt_for_output_docx("Enter the full output .docx path:")
        return input_folder, output_docx

# =============================================================================
# PARSING HELPERS: SECTION HEADINGS, BULLETS, ROLE HEADERS
# =============================================================================
def canonical_section(name: str) -> str:
    """
    Normalize a section name to the canonical set specified in SECTIONS_TO_INCLUDE.
    Fallback to Title Case if unknown; 'Uncategorized' when missing.
    """
    n = (name or "").strip()
    if not n:
        return "Uncategorized"
    # Apply explicit map first
    for k, v in CANONICAL_MAP.items():
        if k.lower() == n.lower():
            return v
    # Exact match in allowed set
    for s in SECTIONS_TO_INCLUDE:
        if s.lower() == n.lower():
            return s
    # Title-case fallback for stability
    return n.title()

def is_heading_paragraph(p) -> str | None:
    """
    Determine whether paragraph 'p' is a section heading using:
    - Word heading styles (Heading 1..3),
    - ALL CAPS short line heuristic,
    - Regex matching for common headings.
    Returns canonical section name or None.
    """
    text = (p.text or "").strip()
    style_name = (getattr(p.style, "name", "") or "").lower()

    if "heading" in style_name:
        return canonical_section(text)
    if text and len(text) <= 60 and text.isupper():
        return canonical_section(text.title())
    for rx in HEADING_COMPILED:
        if rx.match(text):
            return canonical_section(text.title())
    return None

def is_bullet_paragraph(p) -> bool:
    """
    Detect bullet/numbered list items using:
    - Paragraph style name containing 'list' or 'bullet'
    - Leading bullet glyphs (• - – * ·)
    - Numbered patterns like '1. ', 'a) ', 'A. '
    """
    style_name = (getattr(p.style, "name", "") or "").lower()
    if "list" in style_name or "bullet" in style_name:
        return True

    text = (p.text or "").strip()
    if not text:
        return False

    if text[0] in BULLET_CHARS:
        return True
    if re.match(r"^(\d+\.|\d+\)|[a-zA-Z]\)|[a-zA-Z]\.)\s+", text):
        return True
    return False

def clean_bullet_text(text: str) -> str:
    """Remove bullet/number markers and normalize whitespace."""
    t = (text or "").strip()
    t = re.sub(r"^[\u2022\-\–\*\·]+\s+", "", t)  # bullet glyphs
    t = re.sub(r"^(\d+\.|\d+\)|[a-zA-Z]\)|[a-zA-Z]\.)\s+", "", t)  # numbering tokens
    t = re.sub(r"\s+", " ", t)
    return t.strip()

def paragraph_has_bold_run(p) -> bool:
    """True if any run in paragraph is bold—often indicates role headers."""
    try:
        for run in p.runs:
            if run.bold:
                return True
    except Exception:
        pass
    return False

def looks_like_role_header(text: str) -> bool:
    """
    Heuristics to detect role headers within Experience-like sections:
    - Presence of a date range (e.g., 'Jan 2020 – Present', '2019–2024')
    - Common separators for title/company (' - ', ' — ', ' | ')
    - Title-case density with reasonable length
    """
    t = (text or "").strip()
    if not t:
        return False
    if DATE_RANGE.search(t):
        return True
    if " - " in t or " — " in t or " | " in t:
        return True
    words = [w for w in re.split(r"\s+", t) if w]
    titleish = sum(1 for w in words if w[:1].isupper())
    if len(words) >= 2 and titleish / max(len(words), 1) > 0.6 and len(t) <= 120:
        return True
    return False

# =============================================================================
# EXTRACTION: EXPERIENCE ROLES & OTHER SECTIONS
# =============================================================================
def extract_roles_and_bullets_from_experience(paragraphs) -> dict[str, list[str]]:
    """
    Given a list of paragraphs belonging to an Experience-like section,
    detect role headers and collect bullets under each role until the next role.

    Returns: {role_header_text -> [bullets]}
    """
    roles: dict[str, list[str]] = defaultdict(list)
    current_role = None

    for p in paragraphs:
        text = (p.text or "").strip()
        if not text:
            continue

        is_role_header = looks_like_role_header(text) or paragraph_has_bold_run(p)
        # Treat non-bullet role-like lines as role headers
        if is_role_header and not is_bullet_paragraph(p):
            current_role = text
            roles[current_role] = roles.get(current_role, [])
            continue

        # Assign bullets to current role
        if is_bullet_paragraph(p):
            bullet = clean_bullet_text(text)
            if bullet:
                if not current_role:
                    current_role = "Role: Unknown"
                    roles[current_role] = roles.get(current_role, [])
                roles[current_role].append(bullet)

    return roles

def extract_bullets_with_roles_from_docx(path: str) -> tuple[dict[str, list[str]], dict[str, list[str]]]:
    """
    Parse a single .docx resume and return:
      - experience_roles: {role_header -> [bullets]}
      - other_sections:   {section -> [bullets]}

    Method:
      1) Walk paragraphs and table cells; track current section via is_heading_paragraph().
      2) For Experience/Professional Experience, run role-aware extraction.
      3) For other sections, collect bullets normally.
    """
    doc = Document(path)
    current_section = None
    section_to_paragraphs: dict[str, list] = defaultdict(list)

    # Gather paragraphs by the active section
    for p in doc.paragraphs:
        heading = is_heading_paragraph(p)
        if heading:
            current_section = heading
            continue
        sec = canonical_section(current_section or "Uncategorized")
        section_to_paragraphs[sec].append(p)

    # Include table cell paragraphs as part of the stream
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                for p in cell.paragraphs:
                    heading = is_heading_paragraph(p)
                    if heading:
                        current_section = heading
                        continue
                    sec = canonical_section(current_section or "Uncategorized")
                    section_to_paragraphs[sec].append(p)

    experience_roles: dict[str, list[str]] = defaultdict(list)
    other_sections: dict[str, list[str]] = defaultdict(list)

    for sec, plist in section_to_paragraphs.items():
        sec_lower = sec.lower()
        is_experience_like = sec_lower in {"experience", "professional experience"}
        if is_experience_like:
            roles_map = extract_roles_and_bullets_from_experience(plist)
            for role, bullets in roles_map.items():
                if bullets:
                    # per-role dedup within this document
                    if DEDUPLICATE_BULLETS:
                        seen = set()
                        unique = []
                        for b in bullets:
                            key = b.strip().lower()
                            if key not in seen:
                                seen.add(key)
                                unique.append(b)
                        bullets = unique
                    experience_roles[role].extend(bullets)
        else:
            # standard section bullets
            for p in plist:
                if is_bullet_paragraph(p):
                    bullet = clean_bullet_text(p.text)
                    if bullet:
                        other_sections[sec].append(bullet)

    # Dedup in non-experience sections within this document
    if DEDUPLICATE_BULLETS:
        for sec, items in list(other_sections.items()):
            seen = set()
            unique = []
            for b in items:
                key = b.strip().lower()
                if key not in seen:
                    seen.add(key)
                    unique.append(b)
            other_sections[sec] = unique

    return experience_roles, other_sections

# =============================================================================
# OUTPUT: WRITE CONSOLIDATED DOCX
# =============================================================================
def write_collated_doc_by_roles(experience_roles: dict[str, list[str]],
                                other_sections: dict[str, list[str]],
                                output_path: str):
    """
    Generate a single .docx with:
      - 'Experience' heading; each role under level-2 headings with bullets
      - Additional sections in a predictable order, heading per section, bullets underneath
    """
    out = Document()
    normal = out.styles['Normal']
    normal.font.name = 'Calibri'
    normal.font.size = Pt(11)

    out.add_heading('Collated Bullets from Resumes (Role-separated Experience)', level=0)

    # Experience roles (sorted alphabetically for stability)
    if experience_roles:
        out.add_heading('Experience', level=1)
        for role in sorted(experience_roles.keys(), key=lambda s: s.lower()):
            out.add_heading(role, level=2)
            for bullet in experience_roles[role]:
                out.add_paragraph(bullet, style='List Bullet')

    # Other sections rendered in preferred order (and included only if present)
    preferred_order = [
        "Professional Experience",          # if any bullets were placed here (rare; roles usually under 'Experience' heading)
        "Professional Profile",
        "Technical Skills",
        "Additional Skills & Qualifications",
        "Core Competencies",
        "Skills",
        "Education",
        "Certifications",
        "Summary",
        "Uncategorized",
    ]
    for sec in preferred_order:
        if sec in other_sections and other_sections[sec]:
            out.add_heading(sec, level=1)
            for bullet in other_sections[sec]:
                out.add_paragraph(bullet, style='List Bullet')

    out.save(output_path)

# =============================================================================
# FILE DISCOVERY
# =============================================================================
def collect_docx_files(root_folder: str) -> list[str]:
    """Walk the root folder and return all .docx file paths (including subfolders)."""
    docx_files = []
    for dirpath, _, filenames in os.walk(root_folder):
        for f in filenames:
            if f.lower().endswith(".docx"):
                docx_files.append(os.path.join(dirpath, f))
    return docx_files

# =============================================================================
# MAIN ENTRY: ARGUMENTS, PROMPTS, AGGREGATION, DEDUP, WRITE
# =============================================================================
def main():
    """
    Orchestrate the workflow:
      - Read CLI args or prompt/GUI for input/output paths.
      - Validate folder and collect files.
      - Parse each resume; merge Experience roles and other sections globally.
      - Deduplicate globally per role and per section.
      - Write consolidated .docx.
    """
    use_gui = False
    # CLI parsing: script.py [input_folder] [output_docx] [--gui]
    args = [a for a in sys.argv[1:] if a]
    if "--gui" in args:
        use_gui = True
        args = [a for a in args if a != "--gui"]

    if len(args) >= 2:
        input_folder = args[0].strip().strip('"')
        output_docx = args[1].strip().strip('"')
    elif use_gui:
        input_folder, output_docx = pick_paths_gui()
    else:
        print("No CLI arguments provided. Interactive mode:")
        input_folder = prompt_for_folder("Enter the input folder path (OneDrive-synced folder with .docx resumes):")
        output_docx = prompt_for_output_docx("Enter the full output .docx path:")

    # Validate and collect files
    if not os.path.isdir(input_folder):
        print(f"ERROR: Input folder does not exist: {input_folder}")
        return

    files = collect_docx_files(input_folder)
    if not files:
        print(f"ERROR: No .docx files found in (or under) folder: {input_folder}")
        return

    # Global aggregation across resumes
    global_experience_roles: dict[str, list[str]] = defaultdict(list)
    global_other_sections: dict[str, list[str]] = defaultdict(list)

    for path in files:
        fname = os.path.basename(path)
        try:
            exp_roles, other_secs = extract_bullets_with_roles_from_docx(path)
        except Exception as e:
            print(f"WARN: Skipping '{fname}' due to read error: {e}")
            continue

        # Merge Experience roles
        for role, bullets in exp_roles.items():
            if bullets:
                global_experience_roles[role].extend(bullets)

        # Merge other sections, respecting canonical names and allowed set
        for sec, bullets in other_secs.items():
            canon = canonical_section(sec)
            # Include only if whitelisted (except 'Uncategorized', which we keep if present)
            if canon != "Uncategorized":
                if not any(canon.lower() == s.lower() for s in SECTIONS_TO_INCLUDE):
                    continue
            if bullets:
                global_other_sections[canon].extend(bullets)

    # Global deduplication per role and per section
    if DEDUPLICATE_BULLETS:
        for role, items in list(global_experience_roles.items()):
            seen = set()
            unique = []
            for b in items:
                key = b.strip().lower()
                if key not in seen:
                    seen.add(key)
                    unique.append(b)
            global_experience_roles[role] = unique

        for sec, items in list(global_other_sections.items()):
            seen = set()
            unique = []
            for b in items:
                key = b.strip().lower()
                if key not in seen:
                    seen.add(key)
                    unique.append(b)
            global_other_sections[sec] = unique

    # Final check & write
    non_empty_roles = {k: v for k, v in global_experience_roles.items() if v}
    non_empty_sections = {k: v for k, v in global_other_sections.items() if v}
    if not non_empty_roles and not non_empty_sections:
        print("INFO: No bullets detected.")
        return

    os.makedirs(os.path.dirname(output_docx) or ".", exist_ok=True)
    write_collated_doc_by_roles(non_empty_roles, non_empty_sections, output_docx)
    print(f"Done. Wrote: {output_docx}")

if __name__ == "__main__":
    main()